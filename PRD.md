# Product Requirements Document: daemon-rpc

## Product Goals

### Primary Objectives

1. **Generic Daemon Framework**: Reusable daemon/client architecture for Rust applications
2. **Single-Task Processing**: Handle one task at a time with status reporting and cancellation
3. **Version Management**: Build timestamp comparison (generated by consuming crate's build.rs)
4. **Lifecycle Management**: Automatic startup and socket-based coordination

### Success Metrics

- Zero-configuration daemon management
- Sub-100ms warm request latency
- Ready/Busy/Error status reporting with cancellation

## Core Features

### 1. Type-Safe RPC Protocol
- Define custom RPC methods with compile-time type safety
- Automatic request/response serialization
- Built-in error handling and version mismatch detection

### 2. Status Reporting & Cancellation
- Real-time status updates: Ready/Busy(message)/Error(message)
- Task cancellation support during long-running operations
- Status streaming to client applications

### 3. Daemon Lifecycle Management
- Automatic daemon spawning when needed
- Socket-based coordination and communication
- Unix socket-based IPC (Linux/macOS)
- Single daemon instance per ID with automatic restart on version mismatches

## API Design

### Version Management
Applications embed a build timestamp at compile time for version checking between client and daemon. When versions mismatch, the daemon is automatically restarted with the newer version.

### Usage Pattern

**Client Side:**
1. Define RPC methods with associated response types
2. Connect to daemon (auto-spawns if needed)
3. Send requests and receive typed responses
4. Monitor real-time status updates
5. Cancel long-running operations when needed

**Daemon Side:**
1. Implement RPC handler trait for your methods
2. Handle requests with status updates and cancellation support
3. Framework manages daemon spawning and IPC automatically

### Key Behaviors

**Single-Task Processing:**
- Daemon handles one request at a time
- Additional requests are rejected with busy status
- Ensures predictable resource usage

**Cancellation Support:**
- Cross-process task cancellation via dedicated cancel messages
- Two-step cancellation: graceful signal (1s timeout) â†’ force termination
- Multiple clients can cancel tasks running on shared daemon
- Cancellation acknowledgment prevents client-side timeouts
- Handler receives cancellation token for cooperative cancellation
- Automatic state cleanup and status updates on cancellation

**Version Checking:**
- Client and daemon compare build timestamps on every request
- Version mismatch triggers automatic daemon restart
- Ensures client and daemon are always in sync

## Technical Considerations

### Platform Support

Linux and macOS (Unix sockets)

### Performance Requirements

- Cold start: < 500ms, warm requests: < 50ms
- Memory overhead: < 5MB per daemon
- Single-task processing (rejects requests when busy)

### Security Considerations

- Socket file permissions (0600)
- Process credential validation
- No network exposure (local-only)
