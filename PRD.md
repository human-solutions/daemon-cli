# Product Requirements Document: daemon-rpc

## Product Goals

### Primary Objectives

1. **Generic Daemon Framework**: Reusable daemon/client architecture for Rust applications
2. **Single-Task Processing**: Handle one task at a time with status reporting and cancellation
3. **Version Management**: Build timestamp comparison (generated by consuming crate's build.rs)
4. **Lifecycle Management**: Automatic startup, health checks, and cleanup

### Success Metrics

- Zero-configuration daemon management
- Sub-100ms warm request latency
- Ready/Busy/Error status reporting with cancellation

## Core Features

### 1. Generic IPC Protocol

```rust
pub trait RpcMethod: Serialize + DeserializeOwned + Send + Sync {
    type Response: Serialize + DeserializeOwned + Send + Sync;
}

pub struct RpcRequest<M: RpcMethod> {
    pub method: M,
    pub client_build_timestamp: u64,
}

pub enum RpcResponse<R> {
    Success { output: R },
    Error { error: String },
    VersionMismatch { daemon_build_timestamp: u64 },
}
```

**Features:**
- Type-safe method definitions with automatic serialization
- Built-in error handling and version checking

### 2. Simple Status Reporting

```rust
pub enum DaemonStatus {
    Ready,
    Busy(String), // User message describing what the daemon is doing
    Error(String), // Error message describing why the daemon cannot run
}
```

**Features:**
- Ready/Busy/Error status messages with cancellation

### 3. Daemon Client

```rust
pub struct DaemonClient<M: RpcMethod> {
    status_receiver: mpsc::Receiver<DaemonStatus>,
}

impl<M: RpcMethod> DaemonClient<M> {
    pub async fn connect(
        daemon_id: u64,
        daemon_executable: PathBuf,
        build_timestamp: u64,
    ) -> Result<Self>;
    
    pub async fn request(&mut self, method: M) -> Result<RpcResponse<M::Response>>;
    pub async fn cancel(&mut self) -> Result<()>;
}
```

**Features:**
- Automatic daemon spawning if not running
- Real-time status streaming with cancellation support
- Build timestamp-based version checking

## API Design

### Build Script Setup

The consuming binary crate must generate a build timestamp in `build.rs`:

```rust
// build.rs in the consuming crate
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // Embed build timestamp for version checking between client and daemon
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .expect("Time went backwards")
        .as_secs();
    println!("cargo:rustc-env=BUILD_TIMESTAMP={}", timestamp);
}
```

In main.rs or lib.rs

```rust
// Build timestamp embedded at compile time for version checking
use std::sync::LazyLock;
static BUILD_TIMESTAMP: LazyLock<u64> = LazyLock::new(|| {
    env!("BUILD_TIMESTAMP").parse::<u64>()
        .expect("BUILD_TIMESTAMP must be a valid u64")
});

// later it is used when creating the daemon
```

### Client Side

```rust
use daemon_rpc::prelude::*;

#[derive(Serialize, Deserialize)]
enum MyMethod {
    ProcessFile { path: PathBuf },
    GetStatus,
}

impl RpcMethod for MyMethod {
    type Response = String;
}

// Usage
let mut client = DaemonClient::connect(
    12345, // daemon_id
    "/path/to/my-daemon".into(), // daemon_executable
    *BUILD_TIMESTAMP, // build_timestamp
).await?;

// Listen for status updates
tokio::spawn(async move {
    while let Some(status) = client.status_receiver.recv().await {
        match status {
            DaemonStatus::Ready => println!("Daemon is ready"),
            DaemonStatus::Busy(msg) => println!("Daemon is busy: {}", msg),
            DaemonStatus::Error(err) => println!("Daemon error: {}", err),
        }
    }
});

// Make request (daemon rejects if busy with another task)
let response = client.request(MyMethod::ProcessFile {
    path: "src/main.rs".into()
}).await?;

// Cancel if needed
client.cancel().await?;
```

### Daemon Side

```rust
use daemon_rpc::prelude::*;

struct MyDaemon;

#[async_trait]
impl RpcHandler<MyMethod> for MyDaemon {
    async fn handle(&mut self, method: MyMethod, cancel_token: CancellationToken, status_tx: mpsc::Sender<DaemonStatus>) -> Result<String> {
        match method {
            MyMethod::ProcessFile { path } => {
                // Send busy status
                status_tx.send(DaemonStatus::Busy(format!("Processing file: {:?}", path))).await?;

                // Simulate long-running work with cancellation support
                for i in 0..100 {
                    if cancel_token.is_cancelled() {
                        return Err(anyhow::anyhow!("Task cancelled"));
                    }

                    // Do some work
                    tokio::time::sleep(Duration::from_millis(10)).await;

                    // Update status occasionally
                    if i % 20 == 0 {
                        status_tx.send(DaemonStatus::Busy(format!("Processing file: {:?} ({}% complete)", path, i))).await?;
                    }
                }

                // Send ready status when done
                status_tx.send(DaemonStatus::Ready).await?;
                Ok(format!("Processed file: {:?}", path))
            },
            MyMethod::GetStatus => {
                // This is always immediate
                Ok("Ready".to_string())
            },
        }
    }
}

// Usage
let daemon = DaemonServer::new(12345, MyDaemon);

daemon.run().await?;
```

## Technical Considerations

### Platform Support

Linux and macOS (Unix sockets)

### Performance Requirements

- Cold start: < 500ms, warm requests: < 50ms
- Memory overhead: < 5MB per daemon
- Single-task processing (rejects requests when busy)

### Security Considerations

- Socket file permissions (0600)
- Process credential validation
- No network exposure (local-only)
