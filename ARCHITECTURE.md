# Technical Architecture: daemon-rpc

## Overview

This document describes the technical implementation of daemon-rpc, a streaming daemon-client framework for Rust applications. It covers protocol design, system architecture, dependencies, and implementation patterns.

## System Architecture

### File Locations

**Unix Socket:**
- Path: `/tmp/daemon-rpc-{daemon_id}.sock`
- Permissions: `0600` (owner read/write only)
- Multiple daemon instances supported via unique daemon IDs
- Automatically cleaned up on daemon exit

**PID File:**
- Path: `/tmp/daemon-rpc-{daemon_id}.pid`
- Contains daemon process ID for precise process control
- Used for identifying and terminating specific daemon instances
- Automatically cleaned up on daemon exit via cleanup guards
- Removed before spawning new daemon to prevent stale files
- Enables precise process targeting without pattern matching

### Daemon Process Management

**Daemon Executable:**
- Invoked with command-line arguments on spawn
- Required arguments:
  - `--daemon-id <id>` - Identifies the daemon instance
  - `--build-timestamp <timestamp>` - For version checking
- Runs as detached background process
- Single daemon instance per ID enforced via socket file locking

**Spawning Strategy:**
- Automatic daemon spawning on first connection attempt
- Single spawn attempt (fails if daemon doesn't start)
- Wait for socket file to appear before declaring success
- Timeout mechanism for spawn failure detection

### Version Management

**Build Timestamp Comparison:**
- Applications embed build timestamp at compile time
- Client and daemon compare timestamps during handshake
- Version mismatch triggers automatic daemon restart
- Ensures client and daemon are always synchronized
- Build timestamp generated by consuming crate's `build.rs`

## Protocol Implementation

### Message Types

1. **Command(String)** - CLI → Daemon
   - Sent once with full stdin content
   - Variable length, size-limited to prevent DoS

2. **OutputChunk(Bytes)** - Daemon → CLI
   - Streamed output, multiple chunks
   - Raw bytes (no predefined structure)
   - Flushed immediately for low latency

3. **CommandError(String)** - Daemon → CLI
   - Handler error message
   - Sent before connection close on error

4. **VersionCheck** - Bidirectional handshake
   - Contains build timestamp
   - First message in connection

### Message Framing

**Length-Delimited Framing:**
- Variable-length messages with length prefix
- Ensures complete message transmission over socket
- Handles message boundaries automatically
- Prevents partial message reads

**Implementation:**
- Uses length-delimited codec pattern
- 4-byte length prefix (network byte order)
- Maximum message size enforced

### Serialization

**Control Messages:**
- Structured serialization for Command, CommandError, VersionCheck
- Binary protocol for efficiency
- Type-safe message encoding/decoding

**Output Chunks:**
- Raw bytes (no serialization overhead)
- Direct streaming from handler to socket
- Minimal latency from handler to client stdout

**Connection Close:**
- Signals completion or cancellation
- No explicit completion message needed
- Clean EOF handling on both sides

### Buffering Strategy

**Output Streaming:**
- Chunks flushed immediately to minimize latency
- No artificial buffering delays
- Backpressure handling to prevent memory issues
- Configurable chunk size for optimal throughput

**Input Handling:**
- CLI reads entire stdin before connecting
- Single command transmission
- Command size limits enforced

## Communication Flows

### Normal Operation

```
1. CLI connects to socket (auto-spawns daemon if needed)
2. Bidirectional version handshake
   - Mismatch: Stop daemon, spawn new one, retry
   - Match: Proceed to step 3
3. CLI sends Command(stdin_string)
4. Daemon processes command
5. Daemon sends OutputChunk(bytes) repeatedly
6. On success: Daemon closes connection
   On error: Daemon sends CommandError, then closes
7. CLI detects EOF, exits
```

### Cancellation Flow

```
1. User presses Ctrl+C in CLI
2. CLI closes connection immediately
3. Daemon detects broken connection (write failure or EOF)
4. Daemon signals CancellationToken to handler
5. Handler attempts graceful shutdown
6. Timeout enforced: force termination if handler doesn't stop
7. Daemon cleans up resources
8. Daemon ready for next connection
```

### Version Mismatch Flow

```
1. CLI connects, sends VersionCheck(cli_timestamp)
2. Daemon responds VersionCheck(daemon_timestamp)
3. Timestamps differ: mismatch detected
4. CLI terminates old daemon (via PID file)
5. CLI removes socket and PID files
6. CLI spawns new daemon with current timestamp
7. CLI retries connection
```

## Dependencies

### Required Rust Crates

**tokio** (with features: full)
- Async runtime and executor
- Process spawning (`tokio::process`)
- Async I/O primitives
- Timer and timeout support

**serde** (with derive)
- Serialization framework for control messages
- Type-safe message encoding/decoding

**anyhow**
- Error handling and context propagation
- Rich error messages with context chains

**tokio-util** (codec features)
- Length-delimited framing utilities
- Codec infrastructure for socket protocol

**async-trait**
- Async trait support for `CommandHandler`
- Enables trait-based handler interface

### Platform-Specific

**Unix Domain Sockets:**
- `std::os::unix::net::UnixListener`
- `std::os::unix::net::UnixStream`
- File permission control via `std::os::unix::fs::PermissionsExt`

**Process Management:**
- `std::process::Command` for daemon spawning
- Signal handling for process termination
- PID-based process control

## Error Handling

### Error Propagation Strategy

**Result-Based:**
- All fallible operations return `Result<T, E>`
- Errors propagate from handler → daemon → CLI
- Context added at each propagation layer

**Error Types:**
- **Handler Errors**: Business logic failures, returned as `Result` from handler
- **Framework Errors**: Connection, spawn, version mismatch errors
- **I/O Errors**: Socket communication failures

### Error Responsibilities

**Handler:**
- Returns `Result` for business logic errors
- Error converted to `CommandError` message
- Sent to CLI before connection close

**Framework:**
- Handles connection failures
- Manages daemon spawn failures
- Detects version mismatches
- Reports framework errors to CLI stderr

**CLI:**
- Writes framework errors to stderr
- Pipes handler output (including errors) to stdout
- Exit codes indicate error type

### Error Messages

**Clarity:**
- Clear, actionable error descriptions
- User-friendly language (no internal jargon)

**Context:**
- Each layer adds relevant context
- Full error chain available for debugging

**Output:**
- Framework errors → stderr
- Handler output (including error output) → stdout

## Resource Management

### Automatic Cleanup

**RAII Patterns:**
- Socket file cleanup via guard types
- PID file cleanup via guard types
- Drop implementations ensure cleanup on panic

**Cleanup Guarantees:**
- Socket removed on daemon exit (normal or crash)
- PID file removed on daemon exit
- Client connection resources freed on disconnect

**Cleanup Guards:**
- Wrapper types with `Drop` implementations
- Cleanup happens even on panic
- File removal happens before process exit

### Graceful Shutdown

**Cancellation Token Propagation:**
- Handler receives `CancellationToken`
- Token signaled on connection break
- Handler checks token periodically

**Timeout Enforcement:**
- Graceful shutdown timeout (e.g., 5 seconds)
- Force termination if handler doesn't stop
- Prevents hung handlers

**State Cleanup:**
- Handler responsible for cleaning its state
- Framework cleans up socket/PID files
- No residual state between commands

## Performance Targets

**Cold Start:**
- Daemon spawn + first command: < 500ms
- Includes process launch and socket creation

**Warm Requests:**
- Command → first output chunk: < 50ms
- Socket connection overhead minimal

**Memory Overhead:**
- Per-daemon memory: < 5MB
- Streaming chunks, not buffering entire output

**Streaming Latency:**
- Output chunks flush immediately
- No artificial buffering
- Backpressure prevents memory bloat

## Security Considerations

**Socket Permissions:**
- Mode `0600` (owner read/write only)
- Prevents unauthorized access
- Process credential validation

**Command Size Limits:**
- Maximum command length enforced
- Prevents DoS via large commands
- Configurable per application

**Local-Only:**
- Unix sockets (no network exposure)
- Same-user access only
- No remote attack surface

**Process Isolation:**
- Each daemon is isolated process
- No shared state between instances
- Crash isolation
